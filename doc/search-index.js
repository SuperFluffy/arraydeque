var searchIndex = {};
searchIndex["arraydeque"] = {"doc":"A circular buffer with fixed capacity.\nRequires Rust 1.12+","items":[[8,"RangeArgument","arraydeque","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",0,null],[11,"end","","End index (exclusive)",0,null],[3,"ArrayDeque","","`ArrayDeque` is a fixed capacity ring buffer.",null,null],[3,"Iter","","`ArrayDeque` iterator",null,null],[3,"IterMut","","`ArrayDeque` mutable iterator",null,null],[3,"IntoIter","","A by-value `ArrayDeque` iterator",null,null],[3,"Drain","","A draining `ArrayDeque` iterator",null,null],[11,"clone","","",1,null],[11,"drop","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"arraydeque"}}],[11,"new","","Creates an empty `ArrayDeque`.",1,{"inputs":[],"output":{"name":"arraydeque"}}],[11,"get","","Retrieves an element in the `ArrayDeque` by index.",1,null],[11,"get_mut","","Retrieves an element in the `ArrayDeque` mutably by index.",1,null],[11,"swap","","Swaps elements at indices `i` and `j`.",1,null],[11,"capacity","","Return the capacity of the `ArrayVec`.",1,null],[11,"iter","","Returns a front-to-back iterator.",1,null],[11,"iter_mut","","Returns a front-to-back iterator that returns mutable references.",1,null],[11,"as_slices","","Returns a pair of slices which contain, in order, the contents of the\n`ArrayDeque`.",1,null],[11,"as_mut_slices","","Returns a pair of slices which contain, in order, the contents of the\n`ArrayDeque`.",1,null],[11,"len","","Returns the number of elements in the `ArrayDeque`.",1,null],[11,"is_empty","","Returns true if the buffer contains no elements",1,null],[11,"drain","","Create a draining iterator that removes the specified range in the\n`ArrayDeque` and yields the removed items.",1,null],[11,"clear","","Clears the buffer, removing all values.",1,null],[11,"contains","","Returns `true` if the `ArrayDeque` contains an element equal to the\ngiven value.",1,null],[11,"front","","Provides a reference to the front element, or `None` if the sequence is\nempty.",1,null],[11,"front_mut","","Provides a mutable reference to the front element, or `None` if the\nsequence is empty.",1,null],[11,"back","","Provides a reference to the back element, or `None` if the sequence is\nempty.",1,null],[11,"back_mut","","Provides a mutable reference to the back element, or `None` if the\nsequence is empty.",1,null],[11,"pop_front","","Removes the first element and returns it, or `None` if the sequence is\nempty.",1,null],[11,"push_front","","Inserts an element first in the sequence.",1,null],[11,"push_back","","Appends an element to the back of a buffer",1,null],[11,"pop_back","","Removes the last element from a buffer and returns it, or `None` if\nit is empty.",1,null],[11,"swap_remove_back","","Removes an element from anywhere in the `ArrayDeque` and returns it, replacing it with the\nlast element.",1,null],[11,"swap_remove_front","","Removes an element from anywhere in the `ArrayDeque` and returns it,\nreplacing it with the first element.",1,null],[11,"insert","","Inserts an element at `index` within the `ArrayDeque`. Whichever\nend is closer to the insertion point will be moved to make room,\nand all the affected elements will be moved to new positions.",1,null],[11,"remove","","Removes and returns the element at `index` from the `ArrayDeque`.\nWhichever end is closer to the removal point will be moved to make\nroom, and all the affected elements will be moved to new positions.\nReturns `None` if `index` is out of bounds.",1,null],[11,"split_off","","Splits the collection into two at the given index.",1,null],[11,"append","","Moves all the elements of `other` into `Self`, leaving `other` empty.",1,null],[11,"retain","","Retains only the elements specified by the predicate.",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"hash","","",1,null],[11,"index","","",1,null],[11,"index_mut","","",1,null],[11,"from_iter","","",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"into_iter","","",1,null],[11,"extend","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",2,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"next_back","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"next_back","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"drop","","",5,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null]],"paths":[[8,"RangeArgument"],[3,"ArrayDeque"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"Drain"]]};
searchIndex["nodrop"] = {"doc":"","items":[[3,"NoDrop","nodrop","A type holding **T** that will not call its destructor on drop",null,null],[11,"new","","Create a new **NoDrop**.",0,{"inputs":[{"name":"t"}],"output":{"name":"nodrop"}}],[11,"into_inner","","Extract the inner value.",0,null],[11,"drop","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null]],"paths":[[3,"NoDrop"]]};
searchIndex["odds"] = {"doc":"Odds and ends â€” collection miscellania.","items":[[3,"Fix","odds","Fixpoint combinator for rust closures, generalized over the return type.",null,null],[12,"0","","",0,null],[5,"fix","","Fixpoint combinator for rust closures, generalized over the return type.",null,{"inputs":[{"name":"t"},{"name":"f"}],"output":{"name":"r"}}],[5,"ref_eq","","Compare if **a** and **b** are equal *as pointers*.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"ptr_eq","","Compare if **a** and **b** are equal pointers.",null,null],[5,"raw_byte_repr","","Safe to use with any wholly initialized memory `ptr`",null,null],[5,"get_unchecked","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"get_unchecked_mut","","Use `debug_assert!` to check indexing in debug mode. In release mode, no checks are done.",null,null],[5,"debug_assert_unreachable","","Act as `debug_assert!` in debug mode, asserting that this point is not reached.",null,null],[5,"slice_unchecked","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"slice_unchecked_mut","","Check slicing bounds in debug mode, otherwise just act as an unchecked\nslice call.",null,null],[5,"ref_slice","","Create a length 1 slice out of a reference",null,null],[5,"ref_slice_mut","","Create a length 1 mutable slice out of a reference",null,null],[11,"call","","",0,null],[11,"clone","","",0,null],[0,"char","","Extra functions for `char`",null,null],[3,"EncodeUtf8Error","odds::char","Placeholder",null,null],[5,"encode_utf8","","Encode a char into buf using UTF-8.",null,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[0,"string","odds","Extensions to `&amp;str` and `String`",null,null],[3,"Prefixes","odds::string","Iterator of all non-empty prefixes",null,null],[3,"Suffixes","","Iterator of all non-empty suffixes",null,null],[3,"Substrings","","Iterator of all non-empty substrings",null,null],[3,"CharChunks","","An iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",null,null],[3,"CharWindows","","An iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",null,null],[3,"CharStr","","A single-char string.",null,null],[8,"StrExt","","Extra methods for `str`",null,null],[10,"rep","","Repeat the string `n` times.",2,null],[10,"append","","Requires `feature=&quot;std&quot;`",2,null],[10,"prefixes","","All non-empty prefixes",2,null],[10,"suffixes","","All non-empty suffixes",2,null],[10,"substrings","","Produce all non-empty substrings",2,null],[10,"is_acceptable_index","","Return `true` if `index` is acceptable for slicing the string.",2,null],[8,"StrSlice","","Extension trait for `str` for string slicing without panicking",null,null],[10,"get_slice","","Return a slice of the string, if it is in bounds /and on character boundaries/,\notherwise return `None`",3,null],[8,"StringExt","","Extra methods for `String`",null,null],[10,"insert_str","","**Panics** if `index` is out of bounds.",4,null],[8,"StrChunksWindows","","Extension traits for the `char_chunks` and `char_windows` methods",null,null],[10,"char_chunks","","Return an iterator that splits the string in substrings of each `n`\n`char` per substring. The last item will contain the remainder if\n`n` does not divide the char length of the string evenly.",5,null],[10,"char_windows","","Return an iterator that produces substrings of each `n`\n`char` per substring in a sliding window that advances one char at a time.",5,null],[11,"clone","","",6,null],[11,"next","","",6,null],[11,"clone","","",7,null],[11,"next","","",7,null],[11,"clone","","",8,null],[11,"next","","",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next","","",9,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"next","","",10,null],[11,"new","","Create a new string from `c`.",11,{"inputs":[{"name":"char"}],"output":{"name":"charstr"}}],[11,"deref","","",11,null],[0,"vec","odds","Extensions to `Vec`",null,null],[5,"vec","odds::vec","Create a new vec from the iterable",null,{"inputs":[{"name":"i"}],"output":{"name":"vec"}}],[8,"VecExt","","Extra methods for `Vec&lt;T&gt;`",null,null],[10,"splice","","Remove elements in a range, and insert from an iterator in their place.",12,null],[10,"retain_mut","","Retains only the elements specified by the predicate.",12,null],[8,"VecFindRemove","","",null,null],[16,"Item","","",13,null],[10,"find_remove","","Linear search for the first element equal to `elt` and remove\nit if found.",13,null],[10,"rfind_remove","","Linear search for the last element equal to `elt` and remove\nit if found.",13,null],[0,"slice","odds","Extra functions for slices",null,null],[3,"MendSlices","odds::slice","An iterator adaptor that glues together adjacent contiguous slices.",null,null],[3,"RevSlice","","A reversed view of a slice.",null,null],[5,"shared_prefix","","Return the end index of the longest shared (equal) prefix of `a` and `b`.",null,null],[5,"rotate_left","","Rotate `steps` towards lower indices.",null,null],[5,"split_aligned_for","","Split the input slice into three chunks,\nso that the middle chunk is a slice of a larger &quot;block size&quot;\n(for example T could be u64) that is correctly aligned for `T`.",null,null],[8,"SliceFind","","Element-finding methods for slices",null,null],[16,"Item","","",14,null],[10,"find","","Linear search for the first occurrence  `elt` in the slice.",14,null],[10,"rfind","","Linear search for the last occurrence  `elt` in the slice.",14,null],[8,"SliceFindSplit","","Element-finding methods for slices",null,null],[16,"Item","","",15,null],[10,"find_split","","Linear search for the first occurrence  `elt` in the slice.",15,null],[10,"rfind_split","","Linear search for the last occurrence  `elt` in the slice.",15,null],[10,"find_split_mut","","Linear search for the first occurrence  `elt` in the slice.",15,null],[10,"rfind_split_mut","","Linear search for the last occurrence  `elt` in the slice.",15,null],[8,"SliceIterExt","","Extra iterator adaptors for iterators of slice elements.",null,null],[11,"mend_slices","","Return an iterator adaptor that joins together adjacent slices if possible.",16,null],[8,"MendSlice","","A trait for items that can *maybe* be joined together.",null,null],[8,"Pod","","&quot;plain old data&quot;: Types that we can stick arbitrary bit patterns into,\nand thus use them as blocks in `split_aligned_for`.",null,null],[11,"find","","",17,null],[11,"rfind","","",17,null],[11,"clone","","",18,null],[11,"new","","Create a new `MendSlices`.",18,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"fmt","","",17,null],[11,"len","","Return the length of the slice.",17,null],[11,"get","","Get element at index `i`.",17,null],[11,"get_mut","","Get element at index `i`.",17,null],[11,"inner_ref","","",17,null],[11,"inner_mut","","",17,null],[11,"into_boxed_slice","","",17,{"inputs":[{"name":"box"}],"output":{"name":"box"}}],[11,"iter","","Return a by-reference iterator",17,null],[11,"iter_mut","","Return a by-mutable-reference iterator",17,null],[11,"split_at","","",17,null],[11,"split_at_mut","","",17,null],[11,"eq","","",17,null],[11,"eq","","",17,null],[11,"hash","","",17,null],[11,"index","","",17,null],[11,"index_mut","","",17,null],[11,"index","","",17,null],[11,"index_mut","","",17,null],[0,"stride","odds","Licensed under the Apache License, Version 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0 or the MIT license\nhttp://opensource.org/licenses/MIT, at your\noption. This file may not be copied, modified, or distributed\nexcept according to those terms.",null,null],[3,"Stride","odds::stride","(the stride) skipped per iteration.",null,null],[3,"StrideMut","","The mutable equivalent of Stride.",null,null],[11,"from_ptr_len","","Create a Stride iterator from a raw pointer.",19,null],[11,"from_ptr_len","","Create a StrideMut iterator from a raw pointer.",20,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",19,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",19,{"inputs":[{"name":"stride"},{"name":"isize"}],"output":{"name":"stride"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",19,null],[11,"len","","Return the number of elements in the iterator.",19,null],[11,"get","","Return a reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",19,null],[11,"next","","",19,null],[11,"size_hint","","",19,null],[11,"next_back","","",19,null],[11,"index","","Return a reference to the element at a given index.",19,null],[11,"fmt","","",19,null],[11,"from_slice","","Create Stride iterator from a slice and the element step count.",20,null],[11,"from_stride","","Create Stride iterator from an existing Stride iterator",20,{"inputs":[{"name":"stridemut"},{"name":"isize"}],"output":{"name":"stridemut"}}],[11,"swap_ends","","Swap the begin and end and reverse the stride,\nin effect reversing the iterator.",20,null],[11,"len","","Return the number of elements in the iterator.",20,null],[11,"get","","Return a reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",20,null],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"next_back","","",20,null],[11,"index","","Return a reference to the element at a given index.",20,null],[11,"fmt","","",20,null],[11,"clone","","",19,null],[11,"get_mut","","Return a mutable reference to the element of a stride at the\ngiven index, or None if the index is out of bounds.",20,null],[11,"index_mut","","Return a mutable reference to the element at a given index.",20,null],[0,"prelude","odds","prelude of often used traits and functions",null,null],[8,"IndexRange","","**IndexRange** is implemented by Rust&#39;s built-in range types, produced\nby range syntax like `..`, `a..`, `..b` or `c..d`.",null,null],[11,"start","","Start index (inclusive)",21,null],[11,"end","","End index (exclusive)",21,null],[11,"start","","Start index (inclusive)",21,null],[11,"end","","End index (exclusive)",21,null]],"paths":[[3,"Fix"],[3,"EncodeUtf8Error"],[8,"StrExt"],[8,"StrSlice"],[8,"StringExt"],[8,"StrChunksWindows"],[3,"Prefixes"],[3,"Suffixes"],[3,"Substrings"],[3,"CharChunks"],[3,"CharWindows"],[3,"CharStr"],[8,"VecExt"],[8,"VecFindRemove"],[8,"SliceFind"],[8,"SliceFindSplit"],[8,"SliceIterExt"],[3,"RevSlice"],[3,"MendSlices"],[3,"Stride"],[3,"StrideMut"],[8,"IndexRange"]]};
initSearch(searchIndex);
